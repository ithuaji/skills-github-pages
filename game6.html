<!DOCTYPE html>
<html>
<head>
    <title>æˆä¸ºè€å¸ˆï¼</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #a0d8ef;
			-webkit-user-select: none; /* Chrome, Safari */
			-moz-user-select: none; /* Firefox */
			-ms-user-select: none; /* Internet Explorer/Edge */
			user-select: none; /* æ ‡å‡†å†™æ³• */
        }
        #info {
            font-size: 2vh;
            margin: 1vh;
            color: #2c3e50;
        }
        canvas {
            width: 100vmin;
            height: 75vmin;
            max-width: 100%;
            border: 2px solid #2c3e50;
            border-radius: 10px;
            background: #fff;
        }
        #controls {
        display: grid;
        grid-template-areas:
            ". up ."
            "left . right"
            ". down .";
        gap: 10px;
        margin-top: 10px;
    }
    .control-button {
        font-size: 50px;
        padding: 10px 20px;
        background: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    .control-button:active {
        background: #2980b9;
    }
    .control-button.up { grid-area: up; }
    .control-button.down { grid-area: down; }
    .control-button.left { grid-area: left; }
    .control-button.right { grid-area: right; }
        #timer {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2vh;
            color: #2c3e50;
        }
        #restart {
            position: absolute;
            bottom: 20px;
            padding: 10px 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: none;
        }
    </style>
</head>
<body>
    <div id="info">å·²æˆä¸ºå¦ˆå¦ˆï¼š<span id="count">0</span>/38</div>
    <div id="timer">å‰©ä½™æ—¶é—´ï¼š60ç§’</div>
    <canvas id="gameCanvas"></canvas>
    <button id="restart" onclick="location.reload()">é‡æ–°å¼€å§‹</button>

<script>
	let lastTouchEnd = 0;
	document.addEventListener('touchend', (event) => {
	    const now = Date.now();
	    if (now - lastTouchEnd <= 300) { // 300ms å†…çš„åŒå‡»
	        event.preventDefault(); // é˜»æ­¢é»˜è®¤ç¼©æ”¾è¡Œä¸º
	    }
	    lastTouchEnd = now;
	}, false);

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const infoCount = document.getElementById('count');
const timerElement = document.getElementById('timer');
const restartButton = document.getElementById('restart');

// æ¸¸æˆé…ç½®
const config = {
    baseSize: 40,
    playerSpeed: 5,
    beeFollowSpeed: 0.1,
    frogSpeed: 2,
    frogCount: 3,
    timeLimit: 60 // æ–°å¢æ—¶é—´é™åˆ¶
};

// æ¸¸æˆå¯¹è±¡
const game = {
    player: { x: 0, y: 0 },
    bees: [],
    frogs: [],
    tamedCount: 0,
    keys: {},
    scaleFactor: 1,
    startTime: Date.now(), // æ–°å¢å¼€å§‹æ—¶é—´
    gameOver: false // æ–°å¢æ¸¸æˆçŠ¶æ€
};

// åˆå§‹åŒ–ç”»å¸ƒ
function initCanvas() {
    const aspectRatio = 4/3;
    const maxWidth = Math.min(window.innerWidth, 1200);
    const maxHeight = Math.min(window.innerHeight * 0.8, 900);
    
    canvas.width = Math.min(maxWidth, maxHeight * aspectRatio);
    canvas.height = canvas.width / aspectRatio;
    
    game.scaleFactor = canvas.width / 800;
    game.player.x = canvas.width / 2;
    game.player.y = canvas.height / 2;
}

// åˆå§‹åŒ–èœœèœ‚ï¼ˆä¿æŒä¸å˜ï¼‰...

// åˆå§‹åŒ–èœœèœ‚
function initBees() {
    game.bees = [];
    for (let i = 0; i < 38; i++) {
        game.bees.push({
            x: Math.random() * (canvas.width - 60) + 30,
            y: Math.random() * (canvas.height - 60) + 30,
            baseX: 0,
            baseY: 0,
            radius: Math.random() * 15 + 5,
            angle: Math.random() * Math.PI * 2,
            angularSpeed: (Math.random() * 0.08 + 0.02) * (Math.random() < 0.5 ? 1 : -1),
            tamed: false,
            tamedAnimation: null,
            untamedAnimation: null
        });
        game.bees[i].baseX = game.bees[i].x;
        game.bees[i].baseY = game.bees[i].y;
    }
}

// åˆå§‹åŒ–é’è›™ï¼ˆä¿æŒä¸å˜ï¼‰...

// åˆå§‹åŒ–é’è›™
function initFrogs() {
    game.frogs = [];
    for (let i = 0; i < config.frogCount; i++) {
        game.frogs.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            dx: Math.random() * 2 - 1,
            dy: Math.random() * 2 - 1
        });
    }
}

// ç¢°æ’æ£€æµ‹ï¼ˆä¿æŒä¸å˜ï¼‰...

// ç¢°æ’æ£€æµ‹ï¼ˆåŠ¨æ€æ£€æµ‹èŒƒå›´ï¼‰
function checkCollision(x1, y1, x2, y2) {
    const detectRange = config.baseSize * game.scaleFactor;
    return Math.hypot(x1 - x2, y1 - y2) < detectRange;
}

// æ¸¸æˆå¾ªç¯
function gameLoop() {
    if (game.gameOver) return;

    // è®¡ç®—å‰©ä½™æ—¶é—´
    const elapsed = Math.floor((Date.now() - game.startTime) / 1000);
    const remaining = config.timeLimit - elapsed;
    timerElement.textContent = `å‰©ä½™æ—¶é—´ï¼š${remaining}ç§’`;

    // è¶…æ—¶æ£€æµ‹
    if (remaining <= 0) {
        game.gameOver = true;
        ctx.fillStyle = '#2c3e50';
        ctx.font = `${4 * game.scaleFactor}vh Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('ä½ ä¸é…å½“å¥é›„çš„è€å¸ˆï¼ï¼ï¼ä½ ä¸é…å½“å¥é›„çš„è€å¸ˆï¼ï¼ï¼ä½ ä¸é…å½“å¥é›„çš„è€å¸ˆï¼ï¼ï¼', canvas.width/2, canvas.height/2 - 40);
        restartButton.style.display = 'block';
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ç§»åŠ¨ç©å®¶ï¼ˆä¿æŒä¸å˜ï¼‰...

    // ç§»åŠ¨ç©å®¶
    const speed = config.playerSpeed * game.scaleFactor;
    if (game.keys.w) game.player.y -= speed;
    if (game.keys.s) game.player.y += speed;
    if (game.keys.a) game.player.x -= speed;
    if (game.keys.d) game.player.x += speed;
    
    // è¾¹ç•Œé™åˆ¶
    game.player.x = Math.max(30, Math.min(canvas.width - 30, game.player.x));
    game.player.y = Math.max(30, Math.min(canvas.height - 30, game.player.y));
    
    // æ›´æ–°é’è›™ä½ç½®ï¼ˆä¿æŒä¸å˜ï¼‰...

    // æ›´æ–°é’è›™ä½ç½®
    const frogSpeed = config.frogSpeed * game.scaleFactor;
    game.frogs.forEach(frog => {
        frog.x += frog.dx * frogSpeed;
        frog.y += frog.dy * frogSpeed;
        
        if (Math.random() < 0.02) {
            frog.dx = Math.random() * 2 - 1;
            frog.dy = Math.random() * 2 - 1;
        }
        
        frog.x = Math.max(30, Math.min(canvas.width - 30, frog.x));
        frog.y = Math.max(30, Math.min(canvas.height - 30, frog.y));
    });
    
    // å¤„ç†èœœèœ‚é€»è¾‘ï¼ˆä¿æŒä¸å˜ï¼‰...

    // å¤„ç†èœœèœ‚é€»è¾‘
    const followSpeed = config.beeFollowSpeed * game.scaleFactor;
    game.bees.forEach(bee => {
        if (!bee.tamed) {
            bee.angle += bee.angularSpeed;
            bee.x = bee.baseX + Math.cos(bee.angle) * bee.radius;
            bee.y = bee.baseY + Math.sin(bee.angle) * bee.radius;
            
            bee.x = Math.max(30, Math.min(canvas.width - 30, bee.x));
            bee.y = Math.max(30, Math.min(canvas.height - 30, bee.y));
            
            if (checkCollision(game.player.x, game.player.y, bee.x, bee.y)) {
                bee.tamed = true;
                bee.tamedAnimation = Date.now();
                game.tamedCount++;
                infoCount.textContent = game.tamedCount;
            }
        } else {
            const angle = Math.atan2(bee.y - game.player.y, bee.x - game.player.x);
            let targetX = game.player.x + Math.cos(angle) * 40 * game.scaleFactor;
            let targetY = game.player.y + Math.sin(angle) * 40 * game.scaleFactor;
            
            targetX += Math.cos(bee.angle) * 10;
            targetY += Math.sin(bee.angle) * 10;
            
            bee.x += (targetX - bee.x) * followSpeed;
            bee.y += (targetY - bee.y) * followSpeed;
            
            bee.angle += bee.angularSpeed * 0.5;

            game.frogs.forEach(frog => {
                if (checkCollision(bee.x, bee.y, frog.x, frog.y)) {
                    bee.tamed = false;
                    bee.untamedAnimation = Date.now();
                    game.tamedCount--;
                    infoCount.textContent = game.tamedCount;
                    bee.baseX = bee.x;
                    bee.baseY = bee.y;
                }
            });
        }
    });
    
    // ç»˜åˆ¶å…ƒç´ ï¼ˆä¿æŒä¸å˜ï¼‰...

    // ç»˜åˆ¶å…ƒç´ 
    const elementSize = config.baseSize * game.scaleFactor;
    ctx.font = `${elementSize}px Arial`;
    
    ctx.fillText('ğŸ§‘â€ğŸ«', game.player.x - elementSize/2, game.player.y + elementSize/2);
    
    ctx.fillStyle = '#f1c40f';
    game.bees.forEach(bee => {
        ctx.fillText(bee.tamed ? 'ğŸ‘¶' : 'ğŸ§‘â€ğŸ“', bee.x - elementSize/2, bee.y + elementSize/2);
        
        if (bee.tamedAnimation) {
            const animationTime = Date.now() - bee.tamedAnimation;
            if (animationTime < 1000) {
                const alpha = 1 - animationTime / 1000;
                const offsetY = animationTime / 20;
                
                ctx.save();
                ctx.fillStyle = `rgba(46, 204, 113, ${alpha})`;
                ctx.font = `${elementSize * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('å¦ˆå¦ˆï¼', bee.x, bee.y - elementSize - offsetY);
                ctx.restore();
            } else {
                bee.tamedAnimation = null;
            }
        }
        
        if (bee.untamedAnimation) {
            const animationTime = Date.now() - bee.untamedAnimation;
            if (animationTime < 1000) {
                const alpha = 1 - animationTime / 1000;
                const offsetY = animationTime / 20;
                
                ctx.save();
                ctx.fillStyle = `rgba(231, 76, 60, ${alpha})`;
                ctx.font = `${elementSize * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('éå¾å­ä¹Ÿï¼Œå¾ä¸èƒ½ç­”ï¼', bee.x, bee.y - elementSize - offsetY);
                ctx.restore();
            } else {
                bee.untamedAnimation = null;
            }
        }
    });
    
    ctx.fillStyle = '#27ae60';
    game.frogs.forEach(frog => {
        ctx.fillText('ğŸ“±', frog.x - elementSize/2, frog.y + elementSize/2);
    });
    
    if (game.tamedCount === 38) {
        game.gameOver = true;
        ctx.fillStyle = '#2c3e50';
        ctx.font = `${4 * game.scaleFactor}vh Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('æ­å–œï¼æ”¶å…»äº†æ‰€æœ‰å­©å­ï¼æ˜¯æœ€ä¼Ÿå¤§çš„è€å¸ˆï¼', canvas.width/2, canvas.height/2);
        restartButton.style.display = 'block';
        return;
    }
    
    requestAnimationFrame(gameLoop);
}

// çª—å£å¤§å°å˜åŒ–å¤„ç†ï¼ˆä¿æŒä¸å˜ï¼‰...

// çª—å£å¤§å°å˜åŒ–å¤„ç†
function handleResize() {
    initCanvas();
    initBees();
    initFrogs();
}

// äº‹ä»¶ç›‘å¬ï¼ˆä¿æŒä¸å˜ï¼‰...

// äº‹ä»¶ç›‘å¬
window.addEventListener('keydown', (e) => {
    game.keys[e.key.toLowerCase()] = true;
});

window.addEventListener('keyup', (e) => {
    game.keys[e.key.toLowerCase()] = false;
});

window.addEventListener('resize', handleResize);

// åˆå§‹åŒ–æ¸¸æˆï¼ˆä¿æŒä¸å˜ï¼‰...

// åˆå§‹åŒ–æ¸¸æˆ
initCanvas();
initBees();
initFrogs();
gameLoop();

// æ§åˆ¶æŒ‰é’®è„šæœ¬ï¼ˆä¿æŒä¸å˜ï¼‰...
</script>
<div id="controls">
    <button class="control-button up" onmousedown="startMove('up')" onmouseup="stopMove()" ontouchstart="startMove('up')" ontouchend="stopMove()">â¬†ï¸</button>
    <button class="control-button down" onmousedown="startMove('down')" onmouseup="stopMove()" ontouchstart="startMove('down')" ontouchend="stopMove()">â¬‡ï¸</button>
    <button class="control-button left" onmousedown="startMove('left')" onmouseup="stopMove()" ontouchstart="startMove('left')" ontouchend="stopMove()">â¬…ï¸</button>
    <button class="control-button right" onmousedown="startMove('right')" onmouseup="stopMove()" ontouchstart="startMove('right')" ontouchend="stopMove()">â¡ï¸</button>
</div>
<script>
let moveInterval;
function startMove(direction) {
    moveInterval = setInterval(() => move(direction), 50);
}
function stopMove() {
    clearInterval(moveInterval);
}
function move(direction) {
    const speed = 5;
    if (direction === 'up') game.player.y -= speed;
    if (direction === 'down') game.player.y += speed;
    if (direction === 'left') game.player.x -= speed;
    if (direction === 'right') game.player.x += speed;
}
</script>
</body>
</html>
